{"version":3,"sources":["vs/workbench/contrib/output/common/fake","vs/workbench/contrib/output/common/file:/Users/fezhang/workspace/github/github1s/lib/vscode/src/vs/base/common/extpath.ts","vs/workbench/contrib/output/common/file:/Users/fezhang/workspace/github/github1s/lib/vscode/src/vs/base/common/network.ts","vs/workbench/contrib/output/common/file:/Users/fezhang/workspace/github/github1s/lib/vscode/src/vs/base/common/resources.ts","vs/workbench/contrib/output/common/file:/Users/fezhang/workspace/github/github1s/lib/vscode/src/vs/workbench/contrib/output/common/outputLinkComputer.ts"],"names":["__m","__M","deps","result","i","len","length","isPathSeparator","code","exports","toSlashes","osPath","replace","path_1","posix","sep","getRoot","path","firstLetter","charCodeAt","pos","start","slice","isWindowsDriveLetter","indexOf","isUNC","platform_1","isWindows","isNaN","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","char0","isValidBasename","name","isWindowsOS","invalidFileChars","test","lastIndex","trim","isEqual","pathA","pathB","ignoreCase","identityEquals","strings_1","equalsIgnoreCase","isEqualOrParent","base","parentCandidate","separator","startsWithIgnoreCase","sepOffset","charAt","sanitizeFilePath","candidate","cwd","endsWith","isAbsolute","join","normalize","rtrim","isRootOrDriveLetter","pathNormalized","indexOfPath","toLowerCase","parseLineAndColumnAware","rawPath","segments","split","undefined","line","column","forEach","segment","segmentAsNumber","Number","types_1","isNumber","Error","Schemas","inMemory","vscode","internal","walkThrough","walkThroughSnippet","http","https","file","mailto","untitled","data","command","vscodeRemote","vscodeRemoteResource","userData","vscodeCustomEditor","vscodeNotebook","vscodeNotebookCell","vscodeSettings","webviewPanel","vscodeWebview","vscodeWebviewResource","extension","vscodeFileResource","RemoteAuthorities","[object Object]","this","_hosts","Object","create","_ports","_connectionTokens","_preferredWebSchema","_delegate","schema","delegate","authority","host","port","connectionToken","uri","query","encodeURIComponent","uri_1","URI","from","scheme","platform","isWeb","FileAccess","FALLBACK_AUTHORITY","uriOrModule","moduleIdToUrl","toUri","rewrite","isElectronSandboxed","isNative","toCodeFileUri","with","fragment","isUri","parse","toUrl","originalFSPath","uriToFsPath","ExtUri","_ignorePathCasing","uri1","uri2","ignoreFragment","compare","getComparisonKey","toString","network_1","extpath","isEqualAuthority","resource","pathFragment","joinPath","basename","paths","extname","dirname","console","error","normalizedPath","to","relativePath","relative","fromPath","toPath","Math","min","substr","newURI","resolve","a1","a2","fsp","p","fsPath","hasTrailingPathSeparator","isRootSep","extUri","extUriBiasedIgnorePathCase","isLinux","extUriIgnorePathCase","_","bind","basenameOrAuthority","normalizePath","resolvePath","isAbsolutePath","removeTrailingPathSeparator","addTrailingPathSeparator","distinctParents","items","resourceAccessor","candidateResource","some","otherItem","index","push","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","substring","lastIndexOf","property","key","value","set","mime","toLocalResource","localScheme","OutputLinkComputer","ctx","createData","patterns","computePatterns","workspaceFolders","sort","resourceStrA","resourceStrB","map","resourceStr","workspaceFolder","createPatterns","getMirrorModels","find","model","getModel","links","lines","strings","splitLines","getValue","folderUri","folderPatterns","resourceCreator","toResource","folderRelativePath","resources","detectLinks","workspaceFolderPath","workspaceFolderVariants","workspaceFolderVariant","validPathCharacterPattern","pathPattern","strictPathPattern","RegExp","escapeRegExpCharacters","lineIndex","pattern","match","offset","exec","resourceString","lineNumber","columnNumber","format","fullMatch","linkRange","startColumn","startLineNumber","endColumn","endLineNumber","link","range_1","Range","areIntersectingOrTouching","range","url","call"],"mappings":"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","file":"outputLinkComputer.js","sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { startsWithIgnoreCase, equalsIgnoreCase, rtrim } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { sep, posix, isAbsolute, join, normalize } from 'vs/base/common/path';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(1);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(pos + 1);\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isWindowsDriveLetter(pathNormalized.charCodeAt(0))\n\t\t\t&& pathNormalized.charCodeAt(1) === CharCode.Colon\n\t\t\t&& (path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tsegments.forEach(segment => {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t});\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport * as platform from 'vs/base/common/platform';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const userData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebook = 'vscode-notebook';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for loading resources inside of webviews.\n\t */\n\texport const vscodeWebviewResource = 'vscode-webview-resource';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n}\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined; } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\treturn this._delegate(uri);\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&tkn=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: `/vscode-remote-resource`,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nclass FileAccessImpl {\n\n\tprivate readonly FALLBACK_AUTHORITY = 'vscode-app';\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(uri: URI): URI;\n\tasBrowserUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\tasBrowserUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Only convert the URI if we are in a native context and it has `file:` scheme\n\t\tif (platform.isElectronSandboxed && platform.isNative && uri.scheme === Schemas.file) {\n\t\t\treturn this.toCodeFileUri(uri);\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * TODO@bpasero remove me eventually when vscode-file is adopted everywhere\n\t */\n\t_asCodeFileUri(uri: URI): URI;\n\t_asCodeFileUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\t_asCodeFileUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\treturn this.toCodeFileUri(uri);\n\t}\n\n\tprivate toCodeFileUri(uri: URI): URI {\n\t\treturn uri.with({\n\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t// add our own\n\t\t\tauthority: uri.authority || this.FALLBACK_AUTHORITY,\n\t\t\tquery: null,\n\t\t\tfragment: null\n\t\t});\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(uri: URI): URI;\n\tasFileUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\tasFileUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== this.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl!.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\nimport { equalsIgnoreCase, compare as strCompare } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isWindows, isLinux } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\"\n\t * @param parentCandidate A uri which is \"shorter\" then `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see ResourceMap\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/', toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tif (path.indexOf('/') === -1) { // no slashes? it's likely a Windows path\n\t\t\tpath = extpath.toSlashes(path);\n\t\t\tif (/^[a-zA-Z]:(\\/|$)/.test(path)) { // starts with a drive letter\n\t\t\t\tpath = '/' + path;\n\t\t\t}\n\t\t}\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string, a2: string) {\n\t\treturn a1 === a2 || equalsIgnoreCase(a1, a2);\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMirrorModel, IWorkerContext } from 'vs/editor/common/services/editorSimpleWorker';\nimport { ILink } from 'vs/editor/common/modes';\nimport { URI } from 'vs/base/common/uri';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as resources from 'vs/base/common/resources';\nimport * as strings from 'vs/base/common/strings';\nimport { Range } from 'vs/editor/common/core/range';\nimport { isWindows } from 'vs/base/common/platform';\nimport { Schemas } from 'vs/base/common/network';\n\nexport interface ICreateData {\n\tworkspaceFolders: string[];\n}\n\nexport interface IResourceCreator {\n\ttoResource: (folderRelativePath: string) => URI | null;\n}\n\nexport class OutputLinkComputer {\n\tprivate patterns = new Map<URI /* folder uri */, RegExp[]>();\n\n\tconstructor(private ctx: IWorkerContext, createData: ICreateData) {\n\t\tthis.computePatterns(createData);\n\t}\n\n\tprivate computePatterns(createData: ICreateData): void {\n\n\t\t// Produce patterns for each workspace root we are configured with\n\t\t// This means that we will be able to detect links for paths that\n\t\t// contain any of the workspace roots as segments.\n\t\tconst workspaceFolders = createData.workspaceFolders\n\t\t\t.sort((resourceStrA, resourceStrB) => resourceStrB.length - resourceStrA.length) // longest paths first (for https://github.com/microsoft/vscode/issues/88121)\n\t\t\t.map(resourceStr => URI.parse(resourceStr));\n\n\t\tfor (const workspaceFolder of workspaceFolders) {\n\t\t\tconst patterns = OutputLinkComputer.createPatterns(workspaceFolder);\n\t\t\tthis.patterns.set(workspaceFolder, patterns);\n\t\t}\n\t}\n\n\tprivate getModel(uri: string): IMirrorModel | undefined {\n\t\tconst models = this.ctx.getMirrorModels();\n\n\t\treturn models.find(model => model.uri.toString() === uri);\n\t}\n\n\tcomputeLinks(uri: string): ILink[] {\n\t\tconst model = this.getModel(uri);\n\t\tif (!model) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst links: ILink[] = [];\n\t\tconst lines = strings.splitLines(model.getValue());\n\n\t\t// For each workspace root patterns\n\t\tfor (const [folderUri, folderPatterns] of this.patterns) {\n\t\t\tconst resourceCreator: IResourceCreator = {\n\t\t\t\ttoResource: (folderRelativePath: string): URI | null => {\n\t\t\t\t\tif (typeof folderRelativePath === 'string') {\n\t\t\t\t\t\treturn resources.joinPath(folderUri, folderRelativePath);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\t\tlinks.push(...OutputLinkComputer.detectLinks(lines[i], i + 1, folderPatterns, resourceCreator));\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tstatic createPatterns(workspaceFolder: URI): RegExp[] {\n\t\tconst patterns: RegExp[] = [];\n\n\t\tconst workspaceFolderPath = workspaceFolder.scheme === Schemas.file ? workspaceFolder.fsPath : workspaceFolder.path;\n\t\tconst workspaceFolderVariants = [workspaceFolderPath];\n\t\tif (isWindows && workspaceFolder.scheme === Schemas.file) {\n\t\t\tworkspaceFolderVariants.push(extpath.toSlashes(workspaceFolderPath));\n\t\t}\n\n\t\tfor (const workspaceFolderVariant of workspaceFolderVariants) {\n\t\t\tconst validPathCharacterPattern = '[^\\\\s\\\\(\\\\):<>\"]';\n\t\t\tconst validPathCharacterOrSpacePattern = `(?:${validPathCharacterPattern}| ${validPathCharacterPattern})`;\n\t\t\tconst pathPattern = `${validPathCharacterOrSpacePattern}+\\\\.${validPathCharacterPattern}+`;\n\t\t\tconst strictPathPattern = `${validPathCharacterPattern}+`;\n\n\t\t\t// Example: /workspaces/express/server.js on line 8, column 13\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}) on line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n\n\t\t\t// Example: /workspaces/express/server.js:line 8, column 13\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}):line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n\n\t\t\t// Example: /workspaces/mankala/Features.ts(45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts(45,18): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45,18): error\n\t\t\t// Example: /workspaces/mankala/Features Special.ts (45,18): error\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern})(\\\\s?\\\\((\\\\d+)(,(\\\\d+))?)\\\\)`, 'gi'));\n\n\t\t\t// Example: at /workspaces/mankala/Game.ts\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336:9\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${strictPathPattern})(:(\\\\d+))?(:(\\\\d+))?`, 'gi'));\n\t\t}\n\n\t\treturn patterns;\n\t}\n\n\t/**\n\t * Detect links. Made static to allow for tests.\n\t */\n\tstatic detectLinks(line: string, lineIndex: number, patterns: RegExp[], resourceCreator: IResourceCreator): ILink[] {\n\t\tconst links: ILink[] = [];\n\n\t\tpatterns.forEach(pattern => {\n\t\t\tpattern.lastIndex = 0; // the holy grail of software development\n\n\t\t\tlet match: RegExpExecArray | null;\n\t\t\tlet offset = 0;\n\t\t\twhile ((match = pattern.exec(line)) !== null) {\n\n\t\t\t\t// Convert the relative path information to a resource that we can use in links\n\t\t\t\tconst folderRelativePath = strings.rtrim(match[1], '.').replace(/\\\\/g, '/'); // remove trailing \".\" that likely indicate end of sentence\n\t\t\t\tlet resourceString: string | undefined;\n\t\t\t\ttry {\n\t\t\t\t\tconst resource = resourceCreator.toResource(folderRelativePath);\n\t\t\t\t\tif (resource) {\n\t\t\t\t\t\tresourceString = resource.toString();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcontinue; // we might find an invalid URI and then we dont want to loose all other links\n\t\t\t\t}\n\n\t\t\t\t// Append line/col information to URI if matching\n\t\t\t\tif (match[3]) {\n\t\t\t\t\tconst lineNumber = match[3];\n\n\t\t\t\t\tif (match[5]) {\n\t\t\t\t\t\tconst columnNumber = match[5];\n\t\t\t\t\t\tresourceString = strings.format('{0}#{1},{2}', resourceString, lineNumber, columnNumber);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresourceString = strings.format('{0}#{1}', resourceString, lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst fullMatch = strings.rtrim(match[0], '.'); // remove trailing \".\" that likely indicate end of sentence\n\n\t\t\t\tconst index = line.indexOf(fullMatch, offset);\n\t\t\t\toffset = index + fullMatch.length;\n\n\t\t\t\tconst linkRange = {\n\t\t\t\t\tstartColumn: index + 1,\n\t\t\t\t\tstartLineNumber: lineIndex,\n\t\t\t\t\tendColumn: index + 1 + fullMatch.length,\n\t\t\t\t\tendLineNumber: lineIndex\n\t\t\t\t};\n\n\t\t\t\tif (links.some(link => Range.areIntersectingOrTouching(link.range, linkRange))) {\n\t\t\t\t\treturn; // Do not detect duplicate links\n\t\t\t\t}\n\n\t\t\t\tlinks.push({\n\t\t\t\t\trange: linkRange,\n\t\t\t\t\turl: resourceString\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn links;\n\t}\n}\n\nexport function create(ctx: IWorkerContext, createData: ICreateData): OutputLinkComputer {\n\treturn new OutputLinkComputer(ctx, createData);\n}\n"]}